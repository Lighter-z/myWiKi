# 1. 数据类型

```mermaid
graph LR;
    数据类型-->基本类型
    	基本类型-->整型
    		整型-->signed
    		整型-->unsigned
    		整型-->short
    		整型-->int
    		整型-->long&#160long
    数据类型-->构造类型
    	构造类型-->数组
    	构造类型-->结构体&#160struct
    	构造类型-->共用体&#160union
    数据类型-->指针类型
    数据类型-->空类型&#160void
```
### 1.1 字节

| 类型      | 字节   |                |
| ------- | ---- | -------------- |
| byte    | 1    | 最小值-127($2^7$) |
| boolean | 1    |                |
| short   | 2    |                |
| char    | 2    |                |
| int     | 4    |                |
| float   | 4    |                |
| long    | 8    |                |
| double  | 8    |                |

# 2. 关键字
### 2.1 volite
#### 定义
volatile是一个类型修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。
#### 说明
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

示例：   
1. 并行设备的硬件寄存器（如：状态寄存器）  
2. 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)   
3. 多线程应用中被几个任务共享的变量    
4. 防止被编译器优化，入for循环延时程序。   
#### 具体例子
1.一个参数既可以是const还可以是volatile吗？解释为什么？

* 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

2.一个指针可以是volatile 吗？解释为什么？ 

* 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。

3.下面的函数有什么错误：   

```C
int square(volatile int *ptr)
{
  return ptr *ptr;
}
```

* 这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：   
```C
int square(volatile int *ptr)
{
  int a,b;
  a = *ptr;
  b = *ptr;
  return a * b;
}
```

* 由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：   
```C
int square(volatile int *ptr)
{
  int a;
  a = *ptr;
  return a * a;
}
```
### 2.2 register

* 为了提高效率，C语言允许将局部变量得值放在 CPU中的寄存器中，这种变量叫`寄存器变量`，用关键字register作声明。

> 1. 只有局部自动变量和形式参数可以作为寄存器变量
> 2. 一个计算机中的寄存器变量有限，不能随意定义寄存器变量
> 3. 局部静态变量不能定义为寄存器变量

### 2.3 const

* const 只读

* 使用const理由：

    1.关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。不希望参数被修改。

    2.通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。

    3.合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。

* 用法：

    ```C
    const int a0;          //a0是常整数
    int const a1;          //a1是常整数
    const int *a;          //a不是const，而a指向的int型变量是const的
    int const *b;          //b不是const，而b指向的int型变量是const的
    int *const c;          //c指针是const的，而c指向的变量不是const的
    const int * const d;   //d指针是const的，且d指向的变量也是const的
    ```

* const修饰的变量是否可以修改？

    1. 其实是可以修改的（在GCC环境下（不确定））  
    2. 在一些单片机编译环境下，const是不可以修改的，是否可以修改，要根据具体的编译环境   
    3. 在GCC的编译环境下，const是通过编译器在编译时对其进行检查（也就是说，const类型变量如果修改只是编译错误，并不是运行时的错误。只要能够骗过编译器，就可以修改const定义的变量，而且运行时候不会报错）    
    4. 因为GCC在编译时，把const类型变量放在了data段。其实与普通的全局变量放在data段是一样的实现过程，只要通过编译器认定这个变量是const的，运行时不标记为const类型，就可以达到修改const变量的目的 

        * C语言中，const修饰的变量是伪常量，编译器会对其分配内存。
        * C++中，编译器不会对const类型数据分配内存 

    5. 示例：
    ```C
    //示例以一：有警告
    const int a = 6;
    //a = 10;           //直接赋值会报错：assignment of read-only variable
    int *p;
    p = &a;
    *p = 10;
    printf("a = %d \r\n", a);

    //示例以二：无警告
    const int a = 6;
    //a = 10;           //直接赋值会报错：assignment of read-only variable
    int *p;
    p = (int *)&a;
    *p = 10;
    printf("a = %d \r\n", a);
    ```


# 3. 预处理

    * 凡是以`#`开头的均为预处理命令。

### 3.1 条件编译

1. 条件编译中使用的两种条件判定方法分别是`#if`和`ifdef`

### 3.2 #define

  1. 无参宏定义

    * 无参宏定义后不带参数：`#define 标识符字符串`
        * `define`为宏定义命令
        * `标识符`为定义的宏名
        * `字符串`可以是常数，表达式，格式串等等
    * 注意：
        * 宏定义只是一种简单的替换，预处理时对它不做任何的检查。因此，若有错误只能在编译阶段发现。
        * 宏定义不是说明或语句，在行末不需要加分号，若加分号会将分号一起替换。
        * 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。若想终止其作用域可以使用`#undef`命令
        * 宏名若在源程序中用引号括起来，则预处理程序不对其进行宏替换。
        * 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏。在宏展开时，由预处理程序层层替换。
          ```C
          #define PI 3.1415926
          #define S (PI * y * y)
          ```
        * 习惯使用大写表示宏，以便与变量进行区别。也允许使用小写。
        * 可以使用宏定义表示数据类型
          ```C
          #define STU struct stu
          STU a;
          ```
          
  2. 带参宏定义
    
    * 在宏定义中的参数为形式参数；在宏调用中的参数为实际参数。
        * 对于带参数的宏，在调用中，不仅要宏展开，而且要用实参去替代形参
        * 带参宏定义一般格式：`#define 宏名(形参) 字符串`
        * 带参宏调用一般形式：`宏名(形参)`
          ```C
          #define M(y) y*y+3*y    //定义
          int k;
          k = M(5);               //调用
          //预处理后的结果：
          k = 5*5+3*5
          ```
    * 注意：
        * 带参宏定义，宏名与形参之间不能有空格出现
          ```C
          //正确
          #define MAX(a, b) (a > b)?a:b
          //错误
          #define MAX (a, b) (a > b)?a:b
          ```
        * 在带参宏定义中，形参不分配内存单元。因此不必做类型定义。而宏调用中的实参要有具体的值。要用他们去替代形参，因此必须做类型说明。`这是与函数不同的：在函数中，形参和实参是两个不同的量，有各自的作用域，调用时要把实参值赋予形参，进行“值传递”。而带参宏中，只是符号代换，不存在值传递的问题。`


  3. 尽量使用const 替换 #define

    3.1 在旧版本的C中，若定义一个常量必须使用预处理器`#define MAX 1024`，MAX宏定义在预处理阶段就被替换为1024。因此，MAX并没有被加入到符号定义中。如果在程序中运用这个常量获得到一个编译错误时，这时提示信息可能会是1024,而不是MAX.因此查找起来需要花费时间。解决办法就是使用const：`const int MAX = 1024`  

  4. const与#define区别

    4.1 const是有类型的，可以进行编译器类型安全检查；#define是没有类型的，不能进行类型检查。

    4.2 const有作用域；#define不重视作用域，默认定义处到文件结尾。如果需要定义一个在指定作用域下有效的变量，那么不能使用#deifne。

# 4. 头文件包含
  
  * `#include <>`与`#include ""`区别
      
      * <>包含系统文件。例如：c库文件（不是程序员写的库文件）。<> 只会到系统指定的路径下找相应的库文件（隐含意思：不会在当前路径下去寻找），找不到就会提示该文件不存在。
      * " "包含自己写的头文件。" " 现在当前路径下寻找，若没有找到 会到系统指定的路径下寻找，如果没找到 会提示该文件不存在。
      
  * 头文件包含的真实含义:

      * 在#include<xx.h>的那一行，将xx.h这个文件的内容原地展开，替换#include<xx.h>这行语句。处理过程在`预处理`中进行。